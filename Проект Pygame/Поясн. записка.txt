Функция difficulty() отвечает за настройку параметров игры в зависимости от выбранного уровня сложности. Она изменяет значения, которые определяют, сколько урона игрок и враг могут наносить, а также скорость врага.

1. Глобальные переменные: Функция использует глобальные переменные для хранения информации о том, сколько урона наносит игрок (damage_player), сколько урона наносит враг (damage_enemy_pitch) и какова скорость врага (speed_en).

2. Идентификаторы урона: Внутри функции устанавливаются переменные, которые будут использоваться для определения множителей урона для игрока и врага в зависимости от сложности.

3. Выбор уровня сложности: Функция проверяет значение переменной current_difficulty, которая определяет текущий уровень сложности. В зависимости от этого значения устанавливаются разные множители:

   • Для уровня "Большой детина" игрок наносит минимальный урон, а враг — значительно меньший.

   • Для "Идеального баланса" урон игрока немного увеличивается, а урон врага также повышается.

   • На уровне "Суровая реальность" игрок наносит максимальный урон, а враг становится более опасным, нанося полный урон и увеличивая свою скорость.

4. Расчет урона: В конце функции происходит расчет фактического урона для игрока и врага на основе установленных множителей.

Таким образом, функция difficulty() позволяет адаптировать игровой процесс под предпочтения игрока, создавая разные уровни вызова и сложности.

1. Инициализация базы данных: Эта функция создает базу данных и таблицу пользователей, если они еще не существуют. Таблица содержит поля для имени пользователя, пароля, количества убитых врагов и пройденных уровней.

2. Проверка существования пользователя: Эта функция проверяет, зарегистрирован ли пользователь с указанным именем. Она возвращает True, если пользователь найден, и False, если нет.

3. Добавление пользователя: Эта функция позволяет зарегистрировать нового пользователя. Она сначала проверяет, существует ли уже пользователь с таким именем. Если нет, то добавляет его в базу данных и возвращает True. Если пользователь уже есть, возвращает False.

4. Проверка пользователя: Эта функция проверяет, совпадают ли введенные имя пользователя и пароль с данными в базе. Если совпадение найдено, возвращается True, иначе — False.

5. Обновление количества убитых врагов: Эта функция увеличивает счетчик убитых врагов для указанного пользователя на заданное количество.

6. Обновление количества пройденных уровней: Эта функция увеличивает счетчик пройденных уровней для указанного пользователя на заданное количество.

7. Получение статистики (убитые враги): Эта функция возвращает количество убитых врагов для указанного пользователя. Если пользователь не найден, возвращается 0.

8. Получение статистики (пройденные уровни): Эта функция возвращает количество пройденных уровней для указанного пользователя. Если пользователь не найден, также возвращается 0.
register_menu()
▎1. Безопасность паролей

Хранение паролей в открытом виде — это небезопасная практика. Рекомендуется использовать методы хеширования, такие как bcrypt или hashlib, чтобы сохранить пароли в зашифрованном виде. Это поможет защитить данные пользователей в случае утечки базы данных.

▎2. Обработка ошибок

Вместо простого вывода сообщений об ошибках в консоль, можно отображать их на экране игры. Это сделает интерфейс более дружелюбным и интуитивно понятным для пользователей, так как они смогут сразу видеть, что пошло не так.

▎3. Оптимизация кода

Можно создать вспомогательную функцию для обработки ввода текста, чтобы избежать дублирования кода в разных функциях (например, для регистрации и входа). Это сделает код более чистым и легким для понимания.

▎4. Улучшение интерфейса

Добавление визуальных элементов, таких как рамки вокруг полей ввода или изменение цвета при активации, сделает интерфейс более привлекательным и удобным для пользователя. Это поможет пользователям легче ориентироваться в полях ввода.
Функция main_menu() отвечает за отображение главного меню игры и обработку взаимодействия пользователя с ним. Вот подробное описание её работы:

▎Основные элементы функции:

1. Цикл событий:

   • Функция запускает бесконечный цикл, в котором она обрабатывает события, такие как нажатие кнопок и закрытие окна. Если пользователь закрывает окно (событие pygame.QUIT), игра завершает свою работу.

2. Отображение фонового изображения:

   • Внутри цикла вызывается функция screen_back_ground(), которая отвечает за отображение фона меню.

3. Создание фона для кнопок и заголовка:

   • Создается полупрозрачный прямоугольник (surf_k) для фона кнопок и заголовка. Он заполняется темным цветом (DARK_GRAY) и устанавливается с альфа-каналом, чтобы сделать его полупрозрачным.

   • Затем этот прямоугольник отображается на экране.

4. Отображение заголовка:

   • Заголовок "Деревяшки" рисуется на экране с помощью функции draw_text(), которая принимает текст, шрифт и цвет.

5. Создание кнопок:

   • На экран выводятся кнопки для различных действий: "Новая игра", "Продолжить", "Настройки", "Выход" и "Войти". Каждая кнопка создается с помощью метода blit() и отображается с соответствующим текстом.

6. Обработка взаимодействия с кнопками:

   • Получаются текущие координаты мыши и состояние нажатий кнопок.

   • Для каждой кнопки проверяется, наведена ли мышь на неё (с помощью метода collidepoint()). Если мышь наведена, кнопка визуально изменяется (например, меняется изображение).

   • Если кнопка нажата (первый элемент списка mouse_click равен 1), выполняется соответствующее действие:

     • Новая игра: вызывает функцию выбора уровня.

     • Продолжить: проверяет текущий уровень и вызывает соответствующую функцию.

     • Настройки: открывает меню настроек.

     • Войти: открывает меню входа.

     • Выход: завершает работу игры.
Функция level_selection_menu(continue_g) отвечает за отображение меню выбора уровня в игре и обработку взаимодействия пользователя с этим меню. Давайте подробно разберем, как она работает, а также рассмотрим функцию level_one(continue_g).

▎Функция level_selection_menu(continue_g)

1. Определение уровней:

   • Создается список levels, содержащий информацию о каждом уровне: изображение, альтернативное изображение (например, при наведении курсора), позиция на экране и действие, которое будет выполнено при выборе уровня.

2. Основной цикл:

   • Запускается бесконечный цикл, в котором происходит отображение меню и обработка событий.

3. Отображение фона и текста:

   • Вызов функции screen_back_ground() для отображения фона.

   • Используются функции draw_text() для отображения заголовка "Выберите уровень" и инструкции "Нажмите Esc для выхода".

4. Обработка событий:

   • Получение текущей позиции мыши с помощью pygame.mouse.get_pos().

   • Переменная mouse_click используется для отслеживания нажатий кнопок мыши.

   • Обработка событий: закрытие окна, нажатие кнопки мыши и нажатие клавиши Esc для возврата в главное меню.

5. Отображение уровней:

   • Для каждого уровня из списка levels изображение уровня отображается на экране.

   • Проверяется, наведена ли мышь на уровень (с помощью метода collidepoint()), и если это так, отображается альтернативное изображение.

   • Если уровень выбран (нажатие мыши), вызывается соответствующее действие (функция уровня).

6. Обновление экрана:

   • В конце цикла происходит обновление экрана с помощью pygame.display.flip().

▎Функция level_one(continue_g)

1. Определение платформ:

   • Задаются координаты платформ в виде списка plat_co_1, где каждая платформа представлена как список с координатами и размерами (x, y, ширина, высота).

2. Очистка и создание платформ:

   • Очищается список platforms, а затем создаются новые платформы на основе координат из plat_co_1. Каждая платформа представляется объектом pygame.Rect.

3. Создание двери:

   • Создается прямоугольник для двери, который будет находиться в определенной позиции относительно последней платформы.

4. Создание врагов (NPC):

   • Создается список врагов enemies_1, где каждый враг инициализируется с заданными параметрами (позиция, здоровье, скорость).

5. Установка уровня:

   • Переменной ex_level присваивается значение 1, чтобы обозначить текущий уровень.

6. Запуск игры:

   • Если передан аргумент continue_g, вызывается функция continue_game() для продолжения игры; иначе запускается новая игра через функцию game_loop().

1. Инициализация:

   • Устанавливается заголовок окна с помощью pygame.display.set_caption().

   • Определяются начальные параметры игрока: позиция, скорость по оси Y, состояние на земле и направление движения.

2. Создание анимаций:

   • Создается словарь animations, который хранит анимации для различных состояний игрока (бег, стояние, прыжок) в зависимости от направления.

   • Текущий спрайт игрока устанавливается в состояние "стояние вправо".

3. Функция обновления спрайта игрока:

   • Внутренняя функция update_player_sprite отвечает за обновление текущего спрайта игрока в зависимости от его состояния и направления.

   • Если состояние или направление изменяются, старый спрайт удаляется из группы спрайтов, и новый спрайт добавляется.

4. Основной игровой цикл:

   • Бесконечный цикл, который обрабатывает события, обновляет состояние игры и рисует элементы на экране.

   • Обработка событий включает закрытие окна, нажатия клавиш для прыжка и стрельбы, а также паузу игры.

5. Обработка ввода:

   • Считываются нажатия клавиш с помощью pygame.key.get_pressed().

   • Если нажата клавиша влево или вправо, позиция игрока обновляется соответственно. Если игрок на земле — он бежит, иначе — прыгает.

   • Если ни одна из клавиш не нажата, игрок остается в состоянии стояния или прыжка.

6. Проверка границ экрана:

   • Ограничивается движение игрока по горизонтали и вертикали с помощью функции max и min, чтобы он не выходил за пределы экрана.

7. Гравитация:

   • Каждую итерацию цикла к скорости по оси Y добавляется значение гравитации (1), а затем обновляется позиция игрока по оси Y.

▎Дальнейшие шаги

После обработки ввода и обновления позиции игрока в основном игровом цикле обычно будут следовать:

• Проверка коллизий с платформами и другими объектами (например, дверью или врагами).

• Обновление состояния врагов.

• Обработка столкновений между пулями и врагами.

• Отрисовка всех объектов на экране.

• Обновление экрана с помощью pygame.display.flip().
# Функция для продолжения игры
def continue_game(coord_platform, door, enemies, plats):
    global screen, camera_offset_x, camera_offset_y, hp_player, hp_en_pitch, all_sprites



Функция settings_menu отвечает за отображение и управление меню настроек в игре, используя библиотеку Pygame и Pygame GUI. Давайте разберем ее по частям:

▎Основные компоненты функции settings_menu

1. Глобальные переменные:

   • Функция использует глобальные переменные для доступа к текущим настройкам игры, таким как разрешение экрана, сложность и скорость пуль.

2. Настройка начальных значений:

   • В зависимости от текущего разрешения экрана устанавливается скорость пуль (BULLET_SPEED). В данном коде скорость пуль всегда равна 1, независимо от разрешения.

3. Определение разрешений и уровней сложности:

   • Создаются списки разрешений и уровней сложности, которые будут отображаться в выпадающих меню.

4. Создание выпадающих меню:

   • Используются элементы UIDropDownMenu для создания меню выбора уровня сложности и разрешения экрана. Они размещаются на экране с помощью pygame.Rect.

5. Основной цикл обработки событий:

   • Бесконечный цикл, который обрабатывает события Pygame:

     • Закрытие окна игры.

     • Изменение выбранного элемента в выпадающем меню:

       • Если изменен уровень сложности, обновляется переменная current_difficulty и вызывается функция difficulty().

       • Если изменено разрешение экрана, оно разбивается на ширину и высоту, и соответствующие переменные обновляются.

       • В зависимости от нового разрешения обновляется скорость пуль (хотя в текущей реализации она всегда равна 1).

     • Обработка событий для менеджера интерфейса.

6. Обновление состояния интерфейса:

   • Менеджер интерфейса обновляется с помощью manager.update(clock.tick(FPS)).

7. Отрисовка элементов меню:

   • Фон меню отображается с помощью функции screen_back_ground().

   • Рисуются различные текстовые элементы, такие как заголовок меню, уровень сложности, разрешение экрана и статистика игрока (количество убитых врагов и пройденных уровней).

8. Кнопка "Назад":

   • Кнопка "Назад" отображается на экране, и если курсор мыши находится над ней и происходит клик, вызывается функция main_menu() для возврата в главное меню.

9. Обновление экрана:

   • В конце каждого цикла происходит обновление экрана с помощью pygame.display.flip().

▎Основные компоненты класса Bullet

1. Инициализация:

   • Метод __init__ (в вашем коде написан как init, что является ошибкой, так как он должен называться именно __init__) инициализирует объект пули. Он принимает следующие параметры:

     • x и y: начальные координаты пули на экране.

     • direction: направление движения пули (1 для движения вправо, -1 для движения влево).

     • BULLET_SPEED: скорость движения пули.

   • Внутри метода создается прямоугольник (pygame.Rect), который представляет собой область, занимаемую пулей, и устанавливаются значения для других атрибутов, таких как alive (живая ли пуля) и direction.

2. Обновление состояния:

   • Метод update отвечает за обновление позиции пули. Если пуля жива (self.alive равно True), то ее положение по оси x изменяется на величину, равную произведению скорости и направления. Это позволяет пуле двигаться в заданном направлении.

3. Отрисовка:

   • Метод draw отвечает за отображение пули на экране. Он принимает параметры:

     • screen: поверхность, на которой будет рисоваться пуля.

     • camera_offset_x и camera_offset_y: смещения камеры по осям x и y. Это необходимо для правильного отображения пули в зависимости от положения камеры.

     • arrow_r и arrow_l: изображения стрел (или графики), которые будут использоваться для представления пули, в зависимости от направления.

   • Внутри метода проверяется, жива ли пуля. Если да, то в зависимости от направления (self.direction) выбирается соответствующее изображение и оно отображается на экране с учетом смещения камеры.

▎.


Класс Enemy в контексте игры, написанной с использованием Pygame, представляет собой объект, который моделирует врага. Давайте подробнее рассмотрим его структуру и функциональность.

▎Описание класса Enemy

1. Атрибуты класса:

   • x, y: Координаты врага на игровом поле.

   • min_x, max_x: Границы, в пределах которых враг может перемещаться по горизонтали.

   • hp: Здоровье врага, определяющее, сколько урона он может выдержать.

   • speed_enemy: Скорость движения врага, определяющая, насколько быстро он перемещается.

   • direction: Направление движения (например, 1 для движения вправо и -1 для движения влево).

   • alive: Логическое значение, указывающее, жив ли враг (True) или мертв (False).

   • rect: Прямоугольник, представляющий область, занимаемую врагом, что позволяет легко управлять столкновениями и отрисовкой.

2. Методы класса:

   • __init__(self, x, y, min_x, max_x, hp, speed_enemy): Конструктор класса, который инициализирует основные атрибуты врага и создает прямоугольник для управления его положением и столкновениями.

   
   • update(self): Метод, отвечающий за обновление позиции врага. Он изменяет координату x в зависимости от текущего направления и скорости. Если враг достигает границ (minx или maxx), направление меняется на противоположное, что создает эффект "бега взад-вперед".

   • draw(self, screen, camera_offset_x, camera_offset_y, enemy_pitch_r, enemy_pitch_l, front, color_front): Метод для отрисовки врага на экране. В зависимости от направления движения отображается соответствующее изображение (например, враг смотрит вправо или влево). Также отображается текст с текущим количеством здоровья.

3. Логика игры:

   • Враги могут быть частью игровой механики, создавая вызов для игрока. Они могут двигаться по заранее определенным маршрутам или реагировать на действия игрока.

   • Здоровье врага (hp) позволяет внедрить систему урона: когда игрок атакует врага, его здоровье уменьшается. Если здоровье достигает нуля, враг "умирает" (alive становится False).
Описание класса AnimatedSprite

1. Атрибуты класса:

   • frames: Список, в который будут загружены отдельные кадры анимации, полученные из текстурного атласа (sheet).

   • count_frame: Параметр, определяющий скорость смены кадров анимации.

   • cur_frame: Индекс текущего кадра анимации.

   • rect: Прямоугольник, представляющий область спрайта, который используется для управления положением и столкновениями.

2. Методы класса:

   • __init__(self, all_sprites, count_frame, sheet, columns, rows, x, y): Конструктор класса. Он инициализирует основные атрибуты и вызывает метод cut_sheet для нарезки текстурного атласа на отдельные кадры. Обратите внимание, что в оригинальном коде есть ошибка: метод должен называться __init__, а не init.

   • cut_sheet(self, sheet, columns, rows): Этот метод отвечает за нарезку текстурного атласа на отдельные кадры. Он создает прямоугольник (self.rect), который определяет размер каждого кадра, и затем с помощью вложенных циклов извлекает каждый кадр из текстурного атласа и добавляет его в список frames.

   • update(self): Метод, который обновляет текущий кадр анимации. Он проверяет, не вышел ли индекс текущего кадра за пределы списка frames, и затем обновляет изображение спрайта (self.image) на следующий кадр. Кадры сменяются на основе значения count_frame, что позволяет контролировать скорость анимации.
